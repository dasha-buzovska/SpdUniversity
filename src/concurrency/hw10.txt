HW11 - Concurrency
Scheduled downloader & indexer

Summary: реализовать загрузчик файлов через многопоточность и индексатор.

Файлик в любом формате (csv, xml, json) вида:
id | title | tags | url | status

id - номер сущности
title - название книги, статьи, форума и т.д.
tags - Один или несколько тегов через разделитель, например [gift , car, technology ]
url - ссылка на источник
status - NOT_ATTEMPTED (значит, что еще не качали).

Они по сути будут полями сущности WebLink.

Пример содержимого demo.csv:
1000 | Шпаргалка по шаблонам проектирования | [паттерны, шаблоны проектирования, gof, архитектура] | https://habrahabr.ru/post/210288/ |  NOT_ATTEMPTED
1001 | Java 8 Concurrency Tutorial | [java 8, multi-threading, concurrency, threads, tutorials] | http://winterbe.com/posts/2015/04/07/java8-concurrency-tutorial-thread-executor-examples/ | NOT_ATTEMPTED
1002 | Design Patterns: Elements of Reusable Object-Oriented Software | [patterns, got, books, java] | http://www.uml.org.cn/c++/pdf/DesignPatterns.pdf | NOT_ATTEMPTED
Из этих ссылок 2 качаем, а там где *.pdf - нет.

Задача 1. Scheduled Downloader
Реализовать Downloader, который должен запускаться каждые N (секунд | минут | часов) и выкачивать ресурсы по ссылкам из файла demo.csv.
Ресурсы помечаются статусами
SUCCES - если ресурс успешно скачался;
FAILED - если не получилось скачать за заданное время;
NOT-ELIGIBLE - то, что не нужно качать (*.png, *.avi, *.mp3, 18+)
На входе:
Файл demo.csv и
Интервал времени для запуска Downloadera и размер пула потоков задаем через параметры командной строки.
На выходе:
Скачанные ресурсы сохраняются в файлики в папку /downloads/ с именами: 1000.txt, 1001.txt, 1002.txt (<id>.txt)
В консоль выводится линка, по которой качаем файл и после загрузки название файла, в который сохранили контент.
После завершения всех потоков переписываем содержимое файла demo.csv данными с обновленными статусами.

Задача 2. Scheduled Indexer.
Добавляем индексатор, который должен запускаться параллельно с Downloader. Брать из очереди скачанные ресурсы
(Queue<Weblink>) и также в несколько потоков выполнять индексацию.
Пишем фейковый метод, который принимает сущность WebLink и имитируем вызов индексатора ElasticSearch, передавая ему
title, tags и текст (выдранный из html-ки, которую скачали).
На входе:
Интервал времени для запуска Indexera и размер пула потоков задаем через параметры командной строки.
На выходе:
в консоль выводится файлик, который индексируется и id-ка сущности после завершения индексации.

Задача 3. Smart Downloader
В дополнение к задаче 1 для ресурсов, которые не выкачались по ссылке с первого раза делаем M попыток докачать. Где M передаем параметром командной строки.
P.S.: Задача 1 является обязательной, 2 и 3 опциональные (повышенной сложности). Пример schedulera есть в статье и examples, которые я вам скидывал
http://winterbe.com/posts/2015/04/07/java8-concurrency-tutorial-thread-executor-examples/
https://gitlab.com/oleg.novitskiy/examples

